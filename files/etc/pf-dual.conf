# $RuOBSD: pf-dual.conf,v 1.12 2007/09/15 14:58:54 form Exp $
#
# Пример настройки PF для маршрутизатора с двумя внешними каналами
# с трансляцией адресов и переадресацией сервисов во внутреннюю сеть.
#
# Данный пример написан для OpenBSD 4.1 и более новых версий. В старых
# версиях системы нужно добавить "flags S/SA keep state" в pass правила
# с "proto tcp" и "keep state" в остальные pass правила.
#
# В данном примере также настраивается симметричная маршрутизация для
# правильного возврата пакетов в канал, с которого было инициировано
# соединение, независимо от настройки default route.
#
#     WAN_1             WAN_2              LAN
#  84.237.97.17     193.125.180.1           ^
#       ^                 ^                 |
#       |                 |                 +---------------+
#       |                 |                 |               |
#       |                 |                 |               v
# +--- rl0 ------------- fxp0 ------------ fxp1 ---+  +------------+
# |                                                |  | 10.11.12.2 |
# +------------------------------------------------+  +------------+
#

# Внешний интерфейс и шлюз для канала A (WAN_1).
#
ext_if_a	= "rl0"
ext_gw_a	= "84.237.97.17"

# Внешний интерфейс и шлюз для канала B (WAN_2).
#
ext_if_b	= "fxp0"
ext_gw_b	= "193.125.180.1"

# Внутренний интерфейс (LAN).
#
int_if		= "fxp1"

# Обслуживаемые TCP и UDP сервисы. В данном примере маршрутизатор
# является сервером имен, не имеющим slave зон, WWW сервером и
# почтовым сервером. Порт для SMTP сессий не указан в списке так как
# для него используются отдельные правила, предусматривающие использование
# spamd. Если spamd не требуется, следует добавить порт "smtp" в
# tcp_svc и закоментировать строчки, относящиеся к spamd.
#
tcp_svc		= "ssh www https imaps"
udp_svc		= "domain"

# TCP сервисы, обслуживаемые сервером из внутренней сети, и адрес сервера.
# В данном примере открывается доступ с использованием Microsoft Remote
# Desktop Client к локальному серверу 10.11.12.2.
#
tcp_svc_lan	= "3389"
tcp_rdr_lan	= "10.11.12.2"

# Определение таблиц для spamd. В данном примере таблица <spamd-bypass>
# содержит список сетей, которые требуется пропускать напрямую к почтовому
# серверу.
#
table <spamd-bypass> file "/etc/mail/spamd.bypass"
table <spamd-white> persist

# Не фильтровать трафик на lo интерфейсах.
#
set skip on lo

# Нормализовать весь входящий трафик.
#
scrub in

# Подключить NAT/RDR правила, создаваемые ftp-proxy. В данном примере
# ftp-proxy будет использовать канал в который указывает default route.
# Чтобы использовать другой канал нужно явно указать адрес привязки в
# командной строке ftp-proxy (например ftpproxy_flags="-a 193.125.180.254",
# где 193.125.180.254 - наш адрес со стороны канала B).
#
nat-anchor "ftp-proxy/*"
rdr-anchor "ftp-proxy/*"

# Включить трансляцию адресов на внешних интерфейсах.
#
nat on $ext_if_a inet from !(self) -> ($ext_if_a:0)
nat on $ext_if_b inet from !(self) -> ($ext_if_b:0)

# Пропустить FTP сессии из локальной сети через ftp-proxy.
#
rdr pass on $int_if proto tcp to !(self) port ftp -> 127.0.0.1 port 8021

# Переадресовать SMTP сессии в spamd для проверки. Адреса, прошедшие проверку
# или не требующие проверки пропускаются к почтовому серверу. Правила rdr
# здесь НЕ должны содержать слова pass.
#
no rdr proto tcp from <spamd-bypass> to { ($ext_if_a) ($ext_if_b) } port smtp
rdr on $ext_if_a inet proto tcp from !<spamd-white> \
	to ($ext_if_a) port smtp tag EXT_IF_A -> 127.0.0.1 port spamd
rdr on $ext_if_b inet proto tcp from !<spamd-white> \
	to ($ext_if_b) port smtp tag EXT_IF_B -> 127.0.0.1 port spamd

# Педеадресовать TCP сессии для сервисов, обслуживаемых локальным сервером.
# Правила rdr здесь НЕ должны содержать слова pass.
rdr on $ext_if_a inet proto tcp to ($ext_if_a) port { $tcp_svc_lan } \
	tag EXT_IF_A -> $tcp_rdr_lan
rdr on $ext_if_b inet proto tcp to ($ext_if_b) port { $tcp_svc_lan } \
	tag EXT_IF_B -> $tcp_rdr_lan

# Разрешить подключение к переадресованным сервисам из локальной сети по
# внешним адресам.
#
rdr pass on $int_if inet proto tcp to { $ext_if_a $ext_if_b } \
	port { $tcp_svc_lan } tag INT_IF_RDR -> $tcp_rdr_lan
nat on $int_if tagged INT_IF_RDR -> ($int_if:0)

# Подключить правила ftp-proxy.
#
anchor "ftp-proxy/*"

# По умолчанию блокировать весь трафик на внешних интерфейсах.
# Для входящих TCP соединений возвращать RST.
#
block on { $ext_if_a $ext_if_b }
block return on { $ext_if_a $ext_if_b } inet proto tcp

# Выпускать исходящие пакеты. Установить маршрутизацию в зависимости
# от адреса источника. Пакеты с адресом интерфейса A уходят в канал A,
# с адресом интерфейса B - в канал B. Пакеты, уходящие в локальные сети
# данных интерфейсов маршрутизируются обычным способом.
#
pass out route-to ($ext_if_a $ext_gw_a) inet from ($ext_if_a)
pass out route-to ($ext_if_b $ext_gw_b) inet from ($ext_if_b)
pass out inet from { $ext_if_a $ext_if_b } to (self:network)

# Пропускаем входящие пакеты для переадресованых сервисов и spamd.
# Устанавливаем для них симметричную маршрутизацию (если пакет пришел
# из канала A, ответ пойдет через канал A независимо от default route). 
#
pass in quick from ($ext_if_a:network) tagged EXT_IF_A
pass in quick reply-to ($ext_if_a $ext_gw_a) tagged EXT_IF_A
pass in quick from ($ext_if_b:network) tagged EXT_IF_B
pass in quick reply-to ($ext_if_b $ext_gw_b) tagged EXT_IF_B

# Пропустить входящие SMTP сессии для адресов, прошедших проверку или
# не нуждающихся в проверке, с регистрацией на интерфейсе pflog0 (для
# spamlogd).
#
pass in log quick inet proto tcp from ($ext_if_a:network) \
	to ($ext_if_a) port smtp
pass in log quick reply-to ($ext_if_a $ext_gw_a) inet proto tcp \
	to ($ext_if_a) port smtp
pass in log quick inet proto tcp from ($ext_if_b:network) \
	to ($ext_if_b) port smtp
pass in log quick reply-to ($ext_if_b $ext_gw_b) inet proto tcp \
	to ($ext_if_b) port smtp

# Разрешить входящие ICMP PING пакеты.
#
pass in on $ext_if_a reply-to ($ext_if_a $ext_gw_a) inet proto icmp \
	to ($ext_if_a) icmp-type echoreq code 0
pass in on $ext_if_a inet proto icmp from ($ext_if_a:network) \
	to ($ext_if_a) icmp-type echoreq code 0
pass in on $ext_if_b reply-to ($ext_if_b $ext_gw_b) inet proto icmp \
	to ($ext_if_b) icmp-type echoreq code 0
pass in on $ext_if_b inet proto icmp from ($ext_if_b:network) \
	to ($ext_if_b) icmp-type echoreq code 0

# Разрешить входящие TCP сессии для обслуживаемых сервисов.
#
pass in on $ext_if_a reply-to ($ext_if_a $ext_gw_a) inet proto tcp \
	to ($ext_if_a) port { $tcp_svc }
pass in on $ext_if_a inet proto tcp from ($ext_if_a:network) \
	to ($ext_if_a) port { $tcp_svc }
pass in on $ext_if_b reply-to ($ext_if_b $ext_gw_b) inet proto tcp \
	to ($ext_if_b) port { $tcp_svc }
pass in on $ext_if_b inet proto tcp from ($ext_if_b:network) \
	to ($ext_if_b) port { $tcp_svc }

# разрешить входящие UDP сессии для обслуживаемых сервисов.
#
pass in on $ext_if_a reply-to ($ext_if_a $ext_gw_a) inet proto udp \
	to ($ext_if_a) port { $udp_svc }
pass in on $ext_if_a inet proto udp from ($ext_if_a:network) \
	to ($ext_if_a) port { $udp_svc }
pass in on $ext_if_b reply-to ($ext_if_b $ext_gw_b) inet proto udp \
	to ($ext_if_b) port { $udp_svc }
pass in on $ext_if_b inet proto udp from ($ext_if_b:network) \
	to ($ext_if_b) port { $udp_svc }
