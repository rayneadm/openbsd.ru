<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
  <META HTTP-EQUIV="Content-Language" CONTENT="ru">
  <META NAME="copyright" CONTENT="Copyright (c) 2008 by OpenBSD.ru">
  <TITLE>OpenSSH: настройки, секреты, трюки и советы</TITLE>
  <link rel="stylesheet" type="text/css" href="style.css" tppabs="http://www.openbsd.ru/style.css" />
</HEAD>

<BODY>

<H2>OpenSSH: настройки, секреты, трюки и советы</H2>

<HR>

<P>
За последние несколько лет OpenSSH из набора программ для защищенной
системы регистрации, выполнения команд на удаленном хосте и передачи
файлов с одной машины на другую превратился в швейцарский армейский
нож, просто потрясающий своими возможностями. Используете ли вы хотя бы
половину из них?

<P>
<STRONG>Содержание:</STRONG>

<UL>
<LI><A HREF="#SEC00">Отключение прослушивания IPv6 адресов</A>
<LI><A HREF="#SEC01">Адрес и порт прослушивания</A>
<LI><A HREF="#SEC02">Ограничение доступа суперпользователя</A>
<LI><A HREF="#SEC03">Контроль за подключениями пользователей</A>
<LI><A HREF="#SEC04">Пример создания резервных копий</A>
<LI><A HREF="#SEC05">Используем dump в связке с ssh</A>
<LI><A HREF="#SEC06">Передача файлов и каталогов</A>
<LI><A HREF="#SEC07">Безопасный способ получения почты</A>
<LI><A HREF="#SEC08">Почтовый шлюз</A>
<LI><A HREF="#SEC10">Выполнение заданной команды после подключения</A>
<LI><A HREF="#SEC11">Мультиплексирование SSH-сессий</A>
<LI><A HREF="#SEC12">Создание SOCKS-сервера</A>
<LI><A HREF="#SEC13">Сажаем пользователей в песочницу</A>
<LI><A HREF="#SEC15">Скрываем записи о серверах, к которым мы подключались</A>
<LI><A HREF="#SEC16">Управляющие последовательности SSH</A>
<LI><A HREF="#SEC17">Сокращенный набор</A>
<LI><A HREF="#SEC18">Получение доступа к закрытому сервису</A>
<LI><A HREF="#SEC19">Ограничение возможностей перебора паролей с помощью Pf</A>
<LI><A HREF="#SEC20">Перенаправление X11-подключений</A>
<LI><A HREF="#SEC21">Использование аутентификации на базе публичного ключа</A>
<LI><A HREF="#SEC22">VPN на базе SSH</A>
</UL>

<A NAME="SEC00"></A>
<H3>Отключение прослушивания IPv6 адресов</H3>

<P>
По умолчанию sshd(8) слушает как на IPv4 так и на IPv6 адресах.  Для того
что бы отключить возможность работы по IPv6, необходимо изменить параметр
AddressFamily:

<PRE>
AddressFamily inet
</PRE>

<A NAME="SEC01"></A>
<H3>Адрес и порт прослушивания</H3>

<P>
По умолчанию sshd(8) принимает подключения на всех интерфейсах, в чем не
всегда есть необходимость. Если не требуется заходить на сервер
&quot;из вне&quot;, следует ограничить его работу определенным адресом с
помощью параметра ListenAddress:

<PRE>
# ListenAddress 0.0.0.0
ListenAddress 192.168.1.2
</PRE>

<P>
Дополнительно через двоеточие можно указать и номер порта. В данном примере
используется значение порта, заданное глобально параметром Port.

<A NAME="SEC02"></A>
<H3>Ограничение доступа суперпользователя</H3>

<P>
В большинстве дистрибутивов в целях безопасности доступ суперпользователю
по SSH закрыт (PermitRootLogin no), и при попытке зарегистрироваться под root
получаем сообщение об ошибке. Для выполнения задач, требующих привилегий
администратора, приходится заходить под обычным пользователем и использовать
su(1) или sudo(8). Красиво выйти из ситуации поможет директива Match.
В качестве аргумента ей передается критерий отбора (User, Group, Host,
Address), его значение и параметр, который нужно применить. Для примера
разрешим подключение под root только с localhost и из доверенной подсети
192.168.5.0/24:

<PRE>
PermitRootLogin no
Match Host 192.168.5.*,127.0.0.1
	PermitRootLogin yes
</PRE>

<P>
<H3>Контроль неудачных подключений</H3>

<P>
Следующие две директивы позволяют контролировать неудачные подключения
к серверу:

<PRE>
LoginGraceTime 60
MaxStartups 2:50:10
</PRE>

<P>
Параметр LoginGraceTime определяет, по истечению какого времени простаивающее
подключение будет разорвано (в секундах). Значение по умолчанию 120 явно
завышено. Количество параллельных неаутентифицированных подключений к серверу
контролируется при помощи MaxStartups. Запись параметра имеет форму
&quot;start:rate:full&quot;. В нашем случае она означает отключение с
вероятностью 50% при наличии двух неаутентифицированных связей, с линейным
ростом вероятности до 100% при достижении 10.

<A NAME="SEC03"></A>
<H3>Контроль за подключениями пользователей</H3>

<P>
Установки в файлах <span>/etc/ssh/sshrc</span> или
<span>~/.ssh/rc</span> позволяют выполнить некоторые действия
при регистрации пользователя. Здесь можно использовать любые команды оболочки.
Например, отправим администратору на почту уведомление о том, что в систему по
SSH зашел пользователь:

<PRE>
# <STRONG>vi /etc/ssh/sshrc</STRONG>
echo $(date) $SSH_CONNECTION $USER $SSH_TTY | mail -s &quot;ssh login&quot; admin@domain.ru
</PRE>

<A NAME="SEC04"></A>
<H3>Пример создания резервных копий</H3>

<P>
Генерируем пару ключей (секретный и публичный):

<PRE>
$ <STRONG>sudo ssh-keygen -t rsa -C 'remote backup'</STRONG>
Generating public/private rsa key pair.
Enter file in which to save the key (/home/user/.ssh/id_rsa):
/home/user/.ssh/id_rsa_backup
</PRE>

<P>
Добавляем публичный ключ в список авторизованных ключей на удаленной системе:

<PRE>
$ <STRONG>ssh remotehost &quot;umask 077; cat &gt; .ssh/authorized_keys&quot; &lt; .ssh/id_rsa_backup.pub</STRONG>
</PRE>

<P>
Затем редактируем <span>authorized_keys</span> (ключ '-t'
следует использовать при запуске программ, требующих для своей работы наличия
псевдотерминала):

<PRE>
$ <STRONG>ssh -t remotehost vi .ssh/authorized_keys</STRONG>
from=&quot;192.168.0.*,212.34.XX.YY&quot;,command=&quot;cd /work; tar cvf - ./* | bzip2 -9&quot;,
no-pty,no-agent-forwarding,no-X11-forwarding,no-port-forwarding ssh-rsa AAAA[...]
</PRE>

<P>
И запускаем процедуру резервного копирования:

<PRE>
$ <STRONG>ssh -i .ssh/id_rsa_backup remotehost &gt; ~/backup/work-`date +%d%m%Y`.tar.bz2 2&gt;/dev/null</STRONG>
</PRE>

<P>
Каталог /work, находящийся на сервере remotehost, будет сохранен в
архив <span>~/backup/work-11052008.tar.bz2</span>.

<A NAME="SEC05"></A>
<H3>Используем dump в связке с SSH</H3>

<P>
Используя SSH, можно защитить информацию, передаваемую программами, не имеющими
встроенных механизмов шифрования соединения. Например, сделаем бэкап с помощью
dump(8) на удаленный сервер:

<PRE>
$ <STRONG>sudo dump -0au -f - /dev/rwd1a | gzip -9 | ssh remotehost 'dd of=cvs_backup.dump.gz'</STRONG>
</PRE>

<P>
Поскольку в dump(8) встроена возможность передавать данные по сети 
с использованием RSH, существует возможность использования и SSH,
поскольку его функциональность аналогична:

<PRE>
$ <STRONG>ssh remotehost touch /home/user/cvs.dump</STRONG>
$ <STRONG>env RSH=`which ssh` sudo -E dump 0f remotehost:/home/user/cvs.dump /cvs</STRONG>
</PRE>

<A NAME="SEC06"></A>
<H3>Передача файлов и каталогов</H3>

<P>
Передать файл, используя SSH, можно одним из следующих способов:

<PRE>
$ <STRONG>cat myfile | ssh remotehost 'cat &gt; myfile'</STRONG>
$ <STRONG>tar zcf - ~/coding | ssh remotehost 'cat &gt; coding.tgz'</STRONG>
</PRE>

<P>
Чтобы рекурсивно отправить весь каталог, набираем:

<PRE>
$ <STRONG>scp -r mydir user@host.domain.ru:</STRONG>
</PRE>

<P>
Вариант копирования каталога с использованием ssh(1) и tar(1) с локального
хоста на удаленный:
<PRE>
$ <STRONG>tar cf - source | ssh remotehost &quot;(cd /target; tar xpf -)&quot;</STRONG>
</PRE>
и с удаленного хоста на локальный:
<PRE>
$ <STRONG>ssh remotehost &quot;tar cf - source&quot; | (cd /target; tar xpf -)</STRONG>
</PRE>

<A NAME="SEC07"></A>
<H3>Безопасный способ получения почты</H3>

<P>
Для безопасного получения почты с помощью fetchmail можно использовать SSH. Для этого
в конфигурационном файле <span>~/.fetchmailrc</span> необходимо указать
следующее:

<PRE>
poll localhost with protocol pop3 and port 8110:
        preconnect &quot;ssh -f -q -C user@213.167.XX.YY \
	-L 8110:213.167.XX.YY:110 sleep 10&quot; password noIdea;
</PRE>

<P>
Забираем почту:

<PRE>
$ <STRONG>fetchmail</STRONG>
1 message for user at localhost (8062 octets).
reading message user@localhost.domain.ru:1 of 1 (8062 octets)....... flushed
</PRE>

<A NAME="SEC08"></A>
<H3>Почтовый шлюз</H3>

<P>
Настроим 192.168.1.1 на перенаправление входящей и исходящей почты по
шифрованному каналу для клиентов из 192.168.1.0/24 на mail.domain.ru:

<PRE>
$ <STRONG>vi .ssh/config</STRONG>
Host mail
	Hostname mail.domain.ru
	LocalForward 192.168.1.1:8025 mail.domain.ru:25
	LocalForward 192.168.1.1:8110 mail.domain.ru:110
	LocalForward 192.168.1.1:8143 mail.domain.ru:143
	GatewayPorts yes
</PRE>

<P>
Открываем туннель:

<PRE>
$ <STRONG>ssh mail</STRONG>
</PRE>

<A NAME="SEC10"></A>
<H3>Выполнение заданной команды после подключения</H3>

<P>
Параметр ProxyCommand позволяет выполнить произвольную команду. Для примера
подключимся через шлюз к файловому серверу, который находится за NAT:

<PRE>
$ <STRONG>vi .ssh/config</STRONG>
Host gateway
        HostName ns.domain.ru
Host filesrv
        HostName 192.168.5.201
        ProxyCommand ssh gateway nc -w 180 %h %p
</PRE>

<P>
Подключаемся:

<PRE>
$ <STRONG>ssh filesrv</STRONG>
</PRE>

<A NAME="SEC11"></A>
<H3>Мультиплексирование ssh-сессий</H3>

<P>
Использование параметра ControlMaster позволяет ускорить доступ к удаленному
серверу за счет того, что в специальном файле сохраняются все параметры
предыдущего сеанса, которые и используются при повторном подключении. Для
примера создадим две Host-секции:

<PRE>
$ <STRONG>vi .ssh/config</STRONG>
Host srv1
	HostName 213.167.XX.YY
	ControlMaster yes
	# Здесь %r - имя, %h - хост и %p - порт
	ControlPath ~/.ssh/ctl-%r-%h-%p
Host srv1fast
	HostName 213.167.XX.YY
	ControlMaster no
	ControlPath ~/.ssh/ctl-%r-%h-%p
</PRE>

<P>
Теперь на сервере srv1 выполняем утилиту uptime(1), логинимся на нем (чтобы
создать локальный сокет для второго подключения), переходим на другую консоль
и снова запрашиваем статистические счетчики:

<PRE>
ttyp0$ <STRONG>time ssh srv1 uptime</STRONG>
 5:55PM  up 37 days,  9:19, 1 user, load averages: 0.33, 0.32, 0.33
    0m0.77s real     0m0.06s user     0m0.01s system

ttyp0$ <STRONG>ssh srv1</STRONG>
ttyp1$ <STRONG>time ssh srv1fast uptime</STRONG>
 5:57PM  up 37 days,  9:20, 2 users, load averages: 0.37, 0.34, 0.33
    0m0.03s real     0m0.00s user     0m0.01s system
</PRE>

<P>
Из примера видно, что при использовании мультиплексирования соединений время
выполнения команды uptime(1) на удаленном сервере уменьшилось в 25 раз.

<A NAME="SEC12"></A>
<H3>Создание SOCKS-сервера</H3>

<P>
OpenSSH можно использовать как специальный SOCKS-сервер, который поддерживает
более гибкое проксирование, чем простое перенаправление портов. Например,
команда:

<PRE>
$ <STRONG>ssh -D1080 user@domain.ru</STRONG>
</PRE>

<P>
Создает локальный SOCKS5-сервер, который ждет подключения на localhost:1080.
Альтернативный вариант - прописать директиву DynamicForward в
<span>.ssh/config</span>:

<PRE>
$ <STRONG>vi .ssh/config</STRONG>
Host proxy
        HostName ns.domain.ru
        DynamicForward 1080
</PRE>

<P>
Подключаемся, введя <CODE>ssh proxy</CODE>. Протестировать работу SOCKS5-сервера
можно такой командой:

<PRE>
$ <STRONG>echo -n &quot;GET / HTTP/1.0\r\n\r\n&quot; | nc -X 5 -x 127.0.0.1:1080 \
	www.domain.ru 80 | head -4</STRONG>
HTTP/1.1 200 OK
Date: Sat, 23 Feb 2008 14:27:43 GMT
Server: Apache
X-Powered-By: PHP/4.4.1
</PRE>

<P>
Теперь SOCKS-сервер готов к использованию:

<PRE>
$ <STRONG>tsocks thunderbird</STRONG>
</PRE>

<A NAME="SEC13"></A>
<H3>Сажаем пользователей в песочницу</H3>

<P>
В OpenSSH 4.9 появилась долгожданная поддержка chroot(2) для sshd(8),
контролируемая с помощью опции ChrootDirectory. К примеру, заставим
подключающегося по sftp пользователя worker переходить в измененный
корневой каталог data:

<PRE>
# <STRONG>vi /etc/ssh/sshd_config</STRONG>
#Subsystem  sftp   /usr/libexec/sftp-server
Subsystem   sftp   internal-sftp

Match User worker
	X11Forwarding no
	AllowTcpForwarding no
	ForceCommand internal-sftp
	ChrootDirectory /data
</PRE>

<P>
Пример для хостинговых клиентов:

<PRE>
# <STRONG>vi /etc/ssh/sshd_config</STRONG>
#Subsystem  sftp   /usr/libexec/sftp-server
Subsystem sftp internal-sftp

Match Group wwwusers
	X11Forwarding no
	AllowTcpForwarding no
	ForceCommand internal-sftp
	ChrootDirectory /var/www/hosting/%u
</PRE>

<P>
Теперь зарегистрированные пользователи будут допущены только к &quot;своему&quot;
каталогу, при подключении модификатор %u будет заменен именем пользователя.
При необходимости можно использовать %h, который соответствует домашнему
каталогу юзера.

<A NAME="SEC15"></A>
<H3>Скрываем записи о серверах, к которым мы
подключались</H3>

<P>
Некоторые администраторы, возможно, захотят зашифровать все IP и доменные
адреса из файла <span>.ssh/known_hosts</span>. Делается это
следующим образом:

<PRE>
$ <STRONG>echo 'HashKnownHosts' &gt;&gt; ~/.ssh/config</STRONG>
$ <STRONG>ssh-keygen -H -f ~/.ssh/known_hosts</STRONG>
$ <STRONG>head -1 ~/.ssh/known_hosts</STRONG>
+|1|TJ2SaXGqO8uHYeiA92KuNRIKR7M=|GpQB8Qz0tQPqA+nF+ghe37mpcHA= ssh-rsa AAAA[...]
</PRE>

<A NAME="SEC16"></A>
<H3>Управляющие последовательности SSH</H3>

<P>
Управляющие последовательности SSH станут доступны, если в SSH-сессии сначала
нажать &lt;Enter&gt;, затем управляющий символ сеанса (по умолчанию тильда,
задается директивой EscapeChar) и специальную клавишу, которая указывает,
какую именно функцию следует выполнить.

<P>
Допустим, мы с mail.domain.ru зашли на bastion.domain2.ru и решили, что не плохо
было бы открыть обратный шифрованный туннель к почтовому серверу для безопасной
загрузки сообщений. С помощью комбинации клавиш &quot;&lt;Enter&gt;~C&quot; можно
интерактивно управлять локальным и удаленным форвардингами (ключи '-L' и '-R'):

<PRE>
bastion$ <STRONG>&lt;Enter&gt;~C</STRONG>
ssh> <STRONG>-R 8110:mail.domain.ru:110</STRONG>
Forwarding port.
</PRE>

<P>
Проверяем работу созданного почтового туннеля:

<PRE>
bastion$ <STRONG>telnet localhost 8110</STRONG>
+OK Dovecot ready.
</PRE>

<P>
В ответ получен баннер от Dovecot, значит, все в порядке.<BR>
Кстати, обратившись к подсказке, получим список всех доступных ключей и
дополнительных параметров:

<PRE>
bastion$ <STRONG>&lt;Enter&gt;~C</STRONG>
ssh> <STRONG>help</STRONG>
Commands:
      -L[bind_address:]port:host:hostport    Request local forward
      -R[bind_address:]port:host:hostport    Request remote forward
      -KR[bind_address:]port                 Cancel remote forward
</PRE>

<P>
Если в <span>~/.ssh/config</span> установить значение
директивы PermitLocalCommand в yes, то мы сможем выполнять команды в
<EM>локальном</EM> шелле, т.е. на хосте, с которого зашли:

<PRE>
ns$ <STRONG>ssh mx</STRONG>
mx$ <STRONG>&lt;Enter&gt;~C</STRONG>
ssh> <STRONG>!uptime</STRONG> # команда выполняется на хосте ns
 7:02PM  up 100 days, 11 mins, 1 user, load averages: 0.13, 0.21, 0.23
<STRONG>&lt;Enter&gt;</STRONG>
mx$ <STRONG>uptime</STRONG>  # команда выполняется на хосте mx
 7:02PM  up 4 days,  7:34, 1 user, load averages: 0.21, 0.23, 0.19
</PRE>

<P>
Если на предыдущем узле требуется выполнить сразу несколько команд, то
SSH-сессию лучше временно засуспендить (приостановить выполнение программы
ssh):

<PRE>
mx$ <STRONG>&lt;Enter&gt;~&lt;Ctrl-Z&gt;</STRONG>
[1] + Suspended            &quot;ssh&quot; &quot;$@&quot;
</PRE>

<P>
Чтобы перевести SSH-сессию из остановленного режима в активный, следует
воспользоваться командой fg.<BR>
Список текущих SSH-соединений можно просмотреть комбинацией:

<PRE>
mx$ <STRONG>&lt;Enter&gt;~#</STRONG>
The following connections are open:
  #0 client-session (t4 r0 i0/0 o0/0 fd 5/6 cfd -1)
</PRE>

<P>
А для быстрого завершения SSH-сессии ставим точку:

<PRE>
mx$ <STRONG>&lt;Enter&gt;~.</STRONG>
Connection to 213.167.XX.YY closed.
</PRE>

<A NAME="SEC17"></A>
<H3>Сокращенный набор</H3>

<P>
Чтобы в консоли не вводить полное доменное имя, порт и учетную запись для
подключения к удаленной системе, стоит заручиться поддержкой директивы Host:

<PRE>
$ <STRONG>vi ~/.ssh/config</STRONG>
Host mx
	Hostname mx.domain.ru
	Port 2022
	User admin
</PRE>

<P>
Таким образом, достаточно ввести <CODE>ssh mx</CODE>, чтобы соединиться с
нужным хостом.

<A NAME="SEC18"></A>
<H3>Получение доступа к закрытому сервису</H3>

<P>
Многие администраторы в целях безопасности скрывают свои сервера в
демилитаризованной зоне, либо за NAT'ом, и разрешают входящие соединения
только с доверенных IP-адресов и по определенными портам. Поэтому доступ
ко многим полезным ресурсам получить напрямую нельзя. Это как раз тот случай,
когда использование SSH-форвардинга может исправить ситуацию.

<PRE>
$ <STRONG>vi ~/.ssh/config</STRONG>
Host gate
        Hostname gate.domain.ru
# Для ускорения соединений включаем мультиплексирование SSH-сессий
        ControlMaster auto
        ControlPath ~/.ssh/ctl-%r-%h-%p
# Перенаправляем локальный порт на файловый сервер (Win2k3 с поднятым VShell)
        LocalForward 8022 192.168.1.101:22

# Подключаясь к localhost:8022, мы будем попадать на файловый сервер
Host fileserver
        Hostname localhost
        Port 8022
        ControlMaster auto
        ControlPath ~/.ssh/ctl-%r-%h-%p
        HostKeyAlias fileserver
</PRE>

<P>
Соединяемся с узлом gate и проверяем возможность подключения к локальному
порту 8022:

<PRE>
$ <STRONG>ssh -N -f gate</STRONG>
$ <STRONG>telnet localhost 8022</STRONG>
SSH-2.0-VShell_3_0_4_656 VShell
</PRE>

<P>
Теперь можно подключиться к файловому серверу, который находится за NAT'ом,
в обход правил файерола, установленных на шлюзе:

<PRE>
$ <STRONG>ssh fileserver</STRONG>
Microsoft Windows [Version 5.2.3790]
C:\Documents and Settings\Username\My Documents>
</PRE>

<A NAME="SEC19"></A>
<H3>Ограничение возможностей перебора паролей с помощью pf(4)</H3>

<P>
Сервис SSH является любимой мишенью злоумышленников, поэтому следует принять
некоторые меры безопасности. Одна из них - ограничение количества подключений,
чтобы избежать DoS-атаки и перебора паролей.

<PRE>
# <STRONG>vi /etc/pf.conf</STRONG>
table &lt;sshbf&gt; persist
block in log quick on $ext_if inet from &lt;sshbf&gt;
pass in log on $ext_if inet proto tcp to $ext_if port ssh keep state \
	(max-src-conn-rate 5/60, overload &lt;sshbf&gt; flush global)
</PRE>

<P>
Данный набор правил инструктирует фильтр пакетов не допускать более 5
одновременных соединений к 22 порту за 60 секунд.

<A NAME="SEC20"></A>
<H3>Перенаправление X11-подключений</H3>

<P>
Для перенаправления X11-подключений следует использовать ключ '-Y':

<PRE>
$ <STRONG>ssh -Y user@domain.com</STRONG>
</PRE>

<P>
Причем в конфигурационном файле <span>/etc/ssh/sshd_config</span>
параметр X11Forwarding должен быть установлен в &quot;yes&quot;. Если X-сервер
запущен на локальной системе, то необходимо включить и X11UseLocalhost.

<A NAME="SEC21"></A>
<H3>Использование аутентификации на базе публичного ключа</H3>

<P>
См. <A HREF="ssh-pubkey.html" tppabs="http://www.openbsd.ru/docs/steps/ssh-pubkey.html">мини-руководство</A> &quot;шаг за шагом&quot;.

<A NAME="SEC22"></A>
<H3>VPN на базе SSH</H3>

<P>
См. <A HREF="ssh-vpn.html" tppabs="http://www.openbsd.ru/docs/steps/ssh-vpn.html">мини-руководство</A> &quot;шаг за шагом&quot;.

<P>
Советы взяты из статей &quot;<A HREF="javascript:if(confirm('http://www.synack.ru/articles/x_06_2008_xakep_pro_kaleidoskop_tainyh_znanii  \n\nThis file was not retrieved by Teleport Ultra, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.synack.ru/articles/x_06_2008_xakep_pro_kaleidoskop_tainyh_znanii'" tppabs="http://www.synack.ru/articles/x_06_2008_xakep_pro_kaleidoskop_tainyh_znanii">Калейдоскоп тайных знаний</A>&quot;
и &quot;<A HREF="javascript:if(confirm('http://www.synack.ru/articles/x_07_2008_xakep_pro_volshebnye_kriptotunneli  \n\nThis file was not retrieved by Teleport Ultra, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.synack.ru/articles/x_07_2008_xakep_pro_volshebnye_kriptotunneli'" tppabs="http://www.synack.ru/articles/x_07_2008_xakep_pro_volshebnye_kriptotunneli">Волшебные криптотуннели</A>&quot;,
опубликованных в июньском и июльском номерах журнала &quot;<A HREF="javascript:if(confirm('http://www.xakep.ru/  \n\nThis file was not retrieved by Teleport Ultra, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.xakep.ru/'" tppabs="http://www.xakep.ru/">Хакер</A>&quot;
за 2008 год. Авторы статей: Андрей Матвеев и Сергей Яремчук. Коррективы и
уточнения введены проектом OpenBSD.ru.

<HR>
<A HREF="-1.htm" tppabs="http://www.openbsd.ru/docs/."><IMG HEIGHT="24" WIDTH="24" SRC="back.gif" tppabs="http://www.openbsd.ru/images/back.gif"
 ALT="OpenBSD.ru"></A>
<A HREF="mailto:www@openbsd.ru">www@openbsd.ru</A>
<BR>
<SMALL>$RuOBSD: ssh-tips.html,v 1.12 2010/11/01 10:57:47 dinar Exp $</SMALL>
 
</BODY>
</HTML>
